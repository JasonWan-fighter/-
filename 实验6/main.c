//main.c
#include <reg51.h>
#include <intrins.h>
#include <stdio.h>
#include"lcd12864.h"
#define uint	unsigned int
#define uchar	unsigned char

sbit fan = P1 ^ 1;//对应实验箱SDA,模拟风扇
sbit led = P1 ^ 2;//对应实验箱SCL，警告灯
sbit beep = P1 ^ 3;//对应实验箱PWM0， 定义蜂鸣器触发脚

sbit	AD_CS = P2 ^ 0;               //2543片选
sbit	AD_IN = P2 ^ 1;               //2543输入
sbit	AD_OUT = P2 ^ 2;               //2543输出
sbit	AD_CLK = P2 ^ 3;               //2543时钟

char space[5] = { 0x20,0x20,0x20,0x20,'\0' };//空格串
char value[5];//存放测量值
unsigned int ad;//读取ad转换得到的数字量
int beep_cnt = 3;//蜂鸣器每次响持续1000次中断（为1s），响三次即为三秒
int quiet_cnt = 0;//蜂鸣器不发声的计数
int cnt;//定时器中断计数
/*******************************************************************************
延时函数,本延时函数延时较短，可以较快刷新屏幕
*******************************************************************************/
void delay(int us)
{
    while (us--);
}


/*******************************************************************************
TLC2543驱动模块，输入port通道号，输出ad转换值
*******************************************************************************/
uint read2543(uchar port)
{
    uint ad = 0, i;
    AD_CLK = 0;
    AD_CS = 0;
    port <<= 4;                          /*选通道。高四位代表AD通道，低四位自动补0 */

    for (i = 0; i < 12; i++)              /* 进行12次（12位）的数据推送 */
    {
        if (AD_OUT)
            ad |= 0x01;             /* 相当于每次检出输出1时。最低位就给1，否则给0 */
        AD_IN = (bit)port & 0x80;  /* 相当于只取最高位进行与运算 */
        AD_CLK = 1;                    /* 电平抬高 */
        delay(3);                     /* 延时 */
        AD_CLK = 0;                      /* 给低电平 */
        delay(3);                     /* 延时。这里是给一个完整周期的脉冲 */
        port <<= 1;
        ad <<= 1;                  /* 左移一位，为下一次for循环做准备 */
    }
    AD_CS = 1;                            /* 片选端置高，则IO_AD_CLK和Data_Input禁止，Data_Out高阻，EOC置高 */
    ad >>= 1;                          /*上面最后一次for循环多移了一次现在移回来 */
    return(ad);                             /* 返回转换值 */
}


/*********************************************************
定时器T0中断
*********************************************************/
void interrupt_timer0() interrupt 1
{
    TH0 = 0xfc;			       //重新赋值
    TL0 = 0x64;
    cnt++;//每1ms产生一次中断，每一次中断让cnt++，1000次中断就是1s
    //每一千次定时器中断，进行AD转换器数据采集
    if (cnt >= 1000)	           //中断累计1000 1s
    {
        ad = read2543(0x01); //选择的是ADIN1引脚（对应0001），结果得到的是AD值（0~4095）
        sprintf(value, "%d", ad);//将整型变量ad格式化写入字符串value
        if (ad > 2000) {//测量值大于阈值2000，蜂鸣器响3秒，停3秒
            if (quiet_cnt == 0) {
                beep = 1;//启动蜂鸣器
                beep_cnt--;
                if (beep_cnt == 0) {
                    quiet_cnt = 3;
                }
            }
            if (beep_cnt == 0) {
                beep = 0;//关闭蜂鸣器
                quiet_cnt--;
                if (quiet_cnt == 0) {
                    beep_cnt = 3;
                }
            }
        }
        cnt = 0;                 //清0
    }
}



/*******************************************************************************
主函数
*******************************************************************************/
void main(void)
{
    lcd_init();   //显示屏初始化
    lcd_clear_txt();  //显示屏清屏

    put_str(0, 2, "吉林大学");
    put_str(1, 0, "Jilin University");

    EA = 1;//打开总中断
    TMOD = 0x01;	  //T0模式为1
    TH0 = 0xfc;//实验箱使用的CPU的主频是11.0892MHz，计数器加一的频率为11.0892/12=0.9241MHz
    TL0 = 0x64;//定时1ms需要10^(-3)*0.9241M=924.1,65536-924=64612=0FC64H
    ET0 = 1;//ET0 是定时器T0中断允许位
    TR0 = 1;//启动T0

    while (1) {
        if (ad < 1000) {
            put_str(2, 3, "正常");
            fan = 1;//关闭风扇
            led = 1;//关闭报警灯
            beep = 0;//关闭蜂鸣器
        }
        else if (ad < 2000) {
            put_str(2, 3, "警报");
            fan = 0;//启动风扇
            led = ~led;//led实现闪烁
            beep = 0;//关闭蜂鸣器
        }
        else {
            put_str(2, 3, "警报");
            fan = 0;//启动风扇
            led = 0;//报警灯常亮
        }
        //第四行显示测量值
        put_str(3, 1, "测量值");
        put_str(3, 5, space);//先清空该区域
        put_str(3, 5, value);//再写入新的测量值
    }
}

